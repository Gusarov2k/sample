
#1
rvm use 2.5.1@aqua --create // create gemset this version ruby
rvm --ruby-version use 2.5.1@HartlM // create file in progect dir
gem list // list install gems
gem update --system // update system gem

!!! для того что бы не устанавливать документацию на gem нужно:
1. создать фаил в домашней деректории nano ~/.gemrc
2. add code gem: --no-document
3. save file


#2
Другими словами, запись >= всегда устанавливает самый последний гем, тогда
как ~> 4.0.0 установит только незначительное обновление (например, с 4.0.0 до
4.0.1 ), но не позволит установить значительное обновление (например, с 4.0 до
4.1 ).

#3
//maps controllers
bundle exec rake routes

#4
// start rails console
rails console

#command
rails generate scaffold User name:string email:string
bundle exec rake db:migrate

#
В традициях Unix утилита make играет важную роль в сборке выполняемых программ
из исходного кода; у многих хакеров на уровне мышечной памяти зафиксирована
строка
$ ./configure && make && sudo make install
обычно используемая для компиляции кода в Unix-системах (включая Linux и Mac
OS X).
Rake – это Ruby make, make-подобный язык, написанный на Ruby. Rails очень широ-
ко использует Rake, особенно для решения бесчисленных мелких административ-
ных задач, возникающих при разработке веб-приложений, опирающихся на базы
данных. Наиболее распространенной, пожалуй, является команда rake db:migrate ,
но есть и другие; полный список задач, связанных с базами данных, можно уви-
деть, передав параметр -T db :
$ bundle exec rake -T db
Чтобы увидеть все доступные задачи Rake, запустите
$ bundle exec rake -T

#for deploy on Heroky
нужно в файле secret.yml в production: заменить ключ взяв его с настройки хостинга herocu
так же нужно добавить в гем файл во втрой строке версию Ruby - ruby: ruby "2.5.1"

bundle install --without production // Стоит отметить, что --without production является «запоминаемым параметром», то есть он включится автоматически при следующем запуске bundle install .

#
ROLLBACK В Rails это может быть
осуществлено с помощью rails destroy с именем созданного элемента. В частно-
сти, следующие две команды отменяют друг друга:
$ rails generate controller StaticPages home help
$ rails destroy controller StaticPages home help

Аналогично в главе 6 мы создадим модель командой:
$ rails generate model User name:string email:string
Это действие может быть отменено с помощью:
$ rails destroy model User

Миграции изменяют состояние базы данных с помощью команды
$ bundle exec rake db:migrate
Мы можем откатить один шаг миграции:
$ bundle exec rake db:rollback
Чтобы откатить к самому началу (все миграции):
$ bundle exec rake db:migrate VERSION=0
Как вы могли догадаться, подстановка любого другого числа вместо 0 откатит миг­
рации до соответствующей версии, где номера версий образуются из последова-
тельного списка миграций.

#
Каталоги ресурсов
В версиях Rails 3.0 и ниже статические ресурсы хранились в каталоге public/ :
 public/stylesheets ;
 public/javascripts ;
 public/images .
Файлы в этих каталогах (даже в версиях выше 3.0) автоматически возвраща-
ются в ответ на запросы по таким адресам, как http://www.example.com/stylesheets ,
и т. д.
В более поздних версиях определены три канонических каталога для статиче-
ских ресурсов, каждый со своим собственным назначением:
 app/assets : ресурсы для данного приложения;
 lib/assets : ресурсы для библиотек, написанных вашей командой разработ-
чиков;
 vendor/assets : ресурсы сторонних поставщиков.
Как можно догадаться, каждый из этих каталогов имеет подкаталоги для каж-
дого класса ресурсов, например:
$ ls app/assets/
images/ javascripts/ stylesheets/
Теперь нетрудно понять причины выбора места хранения файла CSS, созданно-
го в разделе 5.1.2: custom.css.scss принадлежит учебному приложению, поэтому он
помещен в app/assets/stylesheets .
		Файлы манифестов
После сохранения ресурсов в предназначенных им каталогах можно создать
файлы манифестов (декларации), чтобы сообщить Rails (через гем Sprockets ), как
объединить их и сформировать в один файл. (Это относится к CSS и JavaScript,
но не к изображениям.)Для примера заглянем в начальный файл манифеста для
таблиц стилей приложения (app/assets/stylesheets/application.css)

* vendor/assets/stylesheets или vendor/assets/stylesheets, если они есть,
* могут быть указаны здесь с относительными путями.
*
* Вы можете добавлять сюда свои стили для приложения. Они появятся в конце
* скомпилированного файла и потому будут иметь высший приоритет перед любыми другими
* стилями в других файлах CSS/SCSS в этом каталоге. Как правило, для каждого нового
* раздела стилей лучше создать новый файл.
*
*= require_tree .
*= require_self
*/
Ключевыми строками на самом деле здесь являются CSS-комментарии, именно
их использует Sprockets для включения нужных файлов:
/*
.
.
.
*= require_tree .
*= require_self
*/
Строка
*= require_tree .
гарантирует включение всех файлов CSS из каталога app/assets/stylesheets
(и вложенных подкаталогов) в таблицу стилей CSS приложения. Строка
*= require_self
указывает, где в последовательности загрузки будет включен код самого файла
application.css .
Rails включает вполне адекватный файл манифеста по умолчанию, поэтому
в данной книге нам не придется вносить в них изменения, но при необходимо-
сти вы сможете получить более подробную информацию об этом в статье «Asset
Pipeline» в руководстве к Rails ( http://guides.rubyonrails.org/asset_pipeline.html ).

	Препроцессоры
После сборки ресурсов Rails подготавливает их для добавления в макет сайта,
прогоняя через несколько препроцессоров и комбинируя их с помощью файлов
манифестов. Выбор препроцессора определяется расширением файла; чаще всего
на практике используются: .scss – для Sass, .coffee – для CoffeeScript и .erb – для
встроенного Ruby (ERb). Впервые мы говорили о ERb в разделе 3.4.3, о Sass – в раз-
деле 5.2.2. В этой книге нам не понадобится CoffeeScript, но если вам интересно
узнать­ об этом элегантном маленьком языке, который компилируется в JavaScript,
советую начать с видеоурока об основах CoffeeScript http://railscasts.com/episodes/267-coffeescript-basics // Lesson on ROR !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Препроцессоры можно объединять в цепочки, например файл
foobar.js.coffee
будет обработан препроцессором CoffeeScript, а файл
foobar.js.erb.coffee
будет обработан препроцессорами CoffeeScript и ERb (справа налево, то есть
Coffee­Script сначала).

#
Маршруты в Rails
Чтобы добавить именованные маршруты к статическим страницам учебно-
го приложения, необходимо отредактировать файл маршрутов config/routes.rb ,
с по­мощью которого Rails определяет соответствия между именами маршрутов
и адресами URL. Начнем с обзора маршрута для страницы Home (он был опре-
делен в разделе 3.4.4), который представляет особый случай, а затем определим
набор маршрутов для всех остальных статических страниц.
Мы уже видели три примера определения корневого маршрута, начиная с
root 'application#hello'
в первом приложении (листинг 1.10), затем
root 'users#index'
в мини-приложении (листинг 2.3), и наконец
root 'static_pages#home'
в учебном приложении (листинг 3.37). В каждом случае метод root передает за-
прос по адресу / в контроллер и метод по нашему выбору. Определение корневого
маршрута таким способом имеет еще один важный эффект – создается именован-
ный маршрут, к которому можно обращаться по имени, а не через необработанный
адрес URL. В данном случае это маршруты root_path и root_url , они отличаются
наличием во втором случае полного адреса URL:
root_path -> '/'
root_url -> 'http://www.example.com/'
В этой книге мы последуем общему соглашению об использовании формы _path
во всех случаях, кроме переадресации, когда будет использоваться форма _url .
(Это связано с тем, что стандарт HTTP технически требует полный адрес URL
для переадресации, хотя в большинстве браузеров поддерживаются оба способа.)
Чтобы определить именованные маршруты для страниц Help, About и Contact,
нужно изменить правила get из листинга 5.18, переписав строки, имеющие вид:
get 'static_pages/help'
вот так:
get 'help' => 'static_pages#help'
Второй вариант передает запрос GET к адресу URL /help в метод help контролле-
ра StaticPages, то есть вместо громоздкого /static_pages/help можно использовать
более краткий адрес URL /help . Как и в случае с корневым маршрутом, в резуль-
тате создаются два именованных маршрута, help_path и help_url :
help_path -> '/help'
help_url -> 'http://www.example.com/help'
Изменив подобным образом маршруты для остальных статических страниц из
листинга 5.18, получим определения маршрутов, как показано в листинге 5.22.
Листинг 5.22  Маршруты к статическим страницам (config/routes.rb)
Rails.application.routes.draw do
root 			 'static_pages#home'
get 'help' 	=> 	 'static_pages#help'
get 'about'	 =>  'static_pages#about'
get 'contact' => 'static_pages#contact'
5.3.3. Использование именованных маршрутов
После определения маршрутов, как показано в листинге 5.22, их можно использо-
вать в макете сайта. Это просто означает заполнение второго аргумента в функции
link_to правильным именованным маршрутом. Например, превратим
<%= link_to "About", '#' %>
в
<%= link_to "About", about_path %>
и т. д.

#
Хэшированный пароль
Практически весь механизм поддержки безопасных паролей будет реализован
на основе единственного Rails-метода has_secure_password , который мы включим
в модель User:
class User < ActiveRecord::Base
.
.
.
has_secure_password
end
Вместе с этим методом в модель будут добавлены:
1.атрибут password_digest для хранения хэшированной версии пароля;
2.пара виртуальных атрибутов 2 ( password и password_confirmation ) вместе с про-
верками наличия в них значений на этапе создания объекта и их совпадения;
3.метод authenticate , возвращающий объект пользователя (в ответ на ввод
верного пароля) или false .
Единственное, что действительно необходимо для has_secure_password , – это на-
личие атрибута password_digest . (Название digest (дайджест) пришло из крипто-
графии 3 – это значение хэш-суммы, вычисленное хэш-функцией. В данном случае
хэшированный пароль и дайджест-пароль являются синонимами 4 .) В результате
модель User приобретает вид, как показано на рис. 6.8.
1 https://ru.wikipedia.org/wiki/Хеширование .
2 В данном случае слово виртуальные означает, что атрибуты существуют в объекте моде-
ли, но соответствуют базе данных.
https://ru.wikipedia.org/wiki/Хеш-сумма .
Дайджесты хэшированных паролей часто ошибочно называют зашифрованными паролями.
Например, в исходном коде has_secure_password допущена эта ошибка, как и в первых двух
изданиях данной книги. Эта терминология ошибочна, так как, по определению, шифро-
вание обратимо – шифрование предполагает возможность расшифровывания. Смысл вы-
числения дайджеста пароля, напротив, заключается в необратимости – невозможности по-
лучить исходный пароль из дайджеста. (Спасибо читателю Энди Филипсу (Andy Philips)
за это замечание, подтолкнувшее меня на исправление неточной терминологии.)
Для реализации модели на рис. 6.8 создадим сначала соответствующую мигра-
цию, добавляющую столбец password_digest . Миграции можно дать любое назва-
ние, но по соглашению завершим его окончанием to_users , потому что миграция
описывает добавление столбцов в таблицу users . В результате получаем имя миг­
рации add_password_digest_to_users :
$ rails generate migration add_password_digest_to_users password_digest:string
Мы передали в команду аргумент password_digest:string с именем и типом атри-
бута, который нужно создать. (Сравните с первой командой создания таблицы
users в листинге 6.1, которой передавались аргументы name:string и email:string .)
Аргумент password_digest:string содержит достаточно информации, чтобы Rails
смог создать миграцию
_______________________________________________________________________________
#
Окружения Rails
Rails поставляется с тремя настроенными окружениями: test (тестовое), development
(разработки) и production (промышленное). Окружением по умолчанию для консоли
Rails является окружение разработки:
$ rails console
Loading development environment
>> Rails.env
=> "development"
>> Rails.env.development?
=> true
>> Rails.env.test?
=> false
Как видите, в Rails имеется объект Rails с атрибутом env и логическими методами,
среди которых имеется метод Rails.env.test? , возвращающий true в тестовом окру-
жении и false в остальных.
Если понадобится запустить консоль в другом окружении (например, для отладки
теста), можно передать окружение сценарию console в виде параметра:
$ rails console test
Loading test environment
>> Rails.env
=> "test"
>> Rails.env.test?
=> true
Сервер Rails, так же как консоль, по умолчанию выполняется в окружении разра-
ботки, и для него тоже можно изменить окружение:
$ rails server --environment production
Если попробовать запустить приложение в промышленном окружении, оно не бу-
дет работать без настроенной базы данных, которую можно создать, выполнив
коман­ду rake db:migrate в промышленном окружении:
$ bundle exec rake db:migrate RAILS_ENV=production
(Я считаю, что три разных взаимоисключающих способа переопределения окруже-
ния в консоли, на сервере и для команд миграции могут сбить с толку кого угодно,
поэтому я потрудился показать здесь все три.)
Кстати, если вы развернули учебное приложение на Heroku, определить его окру-
жение можно командой heroku run console :
$ heroku run console
>> Rails.env
=> "production"
>> Rails.env.production?
=> true
Естественно, поскольку Heroku является платформой для развертывания сайтов,
она запускает каждое приложение в промышленном окружении.
______________________________________________________________________

************************************
Unix-процессы
В Unix-подобных системах, таких как Linux и OS X, каждая пользовательская и си-
стемная задача находится в четко определенном контейнере, который называется
процессом. Чтобы увидеть все процессы в системе, можно воспользоваться ко-
мандой ps с параметром aux :
$ ps aux
Чтобы отфильтровать процессы по типам, можно пропустить результаты работы
команды ps через инструмент поиска по шаблону grep , использовав оператор кон-
вейера | :
$ ps aux | grep spring
ubuntu 12241 0.3 0.5 589960 178416 ? Ssl Sep20 1:46
spring app | sample_app | started 7 hours ago
В этом выводе можно заметить множество деталей, самой важной из которых яв-
ляется идентификатор (id) процесса, или pid . Остановить ненужный процесс можно командой kill , передав с ее помощью сигнал завершения (с кодом 9 1 ) процессу
по его идентификатору pid :
$ kill -9 12241
Я рекомендую этот прием для остановки отдельных процессов, таких как Rails-
сервер (идентификатор pid , которого можно получить командой ps aux | grep server ),
но иногда бывает удобнее останавливать сразу все процессы, соответствующие
определенному имени программы, например все процессы spring , захламляющие
систему. В этом случае стоит сначала попробовать остановить их с помощью са-
мой команды spring :
$ spring stop
Иногда этот прием не срабатывает, тогда можно остановить все процессы с име-
нем spring , вызвав команду pkill :
$ pkill -9 -f spring
Каждый раз, когда процесс ведет себя не так, как ожидается, или кажется завис-
шим, запустите сначала ps aux , чтобы увидеть, что происходит, и только потом kill
-9<pid> или pkill -9 -f <имя> .
******************************************
